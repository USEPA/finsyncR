invert_NLCD <- getNLCDData(data = inverts_NAWQA_sites,
scale = "Cat",
group = T)
inverts_NAWQA <- datInv %>%
left_join(invert_NLCD)
inverts_NAWQA$NLCDGroup <- ifelse(inverts_NAWQA$PctCrop_Cat > 49.9,
"Crop",
ifelse(inverts_NAWQA$PctUrb_Cat > 49.9,
"Urban",
"Other"))
inverts_NAWQA <- inverts_NAWQA %>%
filter(!is.na(NLCDGroup)) %>%
group_by(CollectionYear, NLCDGroup) %>%
summarize(count = n())
View(inverts_NAWQA)
inverts_NAWQA <- datInv %>%
left_join(invert_NLCD)
inverts_NAWQA$NLCDGroup <- ifelse(inverts_NAWQA$PctCrop_Cat > 49.9,
"Crop",
ifelse(inverts_NAWQA$PctUrb_Cat > 49.9,
"Urban",
"Other"))
inverts_NAWQA <- inverts_NAWQA %>%
filter(!is.na(NLCDGroup)) %>%
filter(CollectionYear == "2013")
Cropinverts <- split(inverts_NAWQA, inverts_NAWQA$NLCDGroup)[[1]]
Otherinverts <- split(inverts_NAWQA, inverts_NAWQA$NLCDGroup)[[2]]
Urbaninverts <- split(inverts_NAWQA, inverts_NAWQA$NLCDGroup)[[3]]
Cropinverts.vegdists <- as.matrix(
vegdist(
Cropinverts[-c(1:30,587:592)], method = "jaccard"))[lower.tri(
as.matrix(
vegdist(
Cropinverts[-c(1:30, 587:592)], method = "jaccard")))]
Cropinverts.geodists <- as.matrix(
distm(
Cropinverts[,c("Longitude_dd", "Latitude_dd")]))[lower.tri(
as.matrix(
distm(Cropinverts[,c("Longitude_dd", "Latitude_dd")])))] / 1e+6
m <- 0.5 * (sqrt((8 * length(Cropinverts.geodists)) + 1) + 1)
Cropinverts.geodists <- Cropinverts.geodists[which(Cropinverts.geodists != -1)]
##Create the identifier for the random terms and itentity matrix
ID <- ResistanceGA::To.From.ID(m)
##Create the sparse matrix object for the MLPE model (identity matrix)
ZZ <- ZZ.mat(ID = ID)
##Join data together into a single dataframe
dat <- data.frame(ID, Cropinverts.geodists, Cropinverts.vegdists, LandUse = "Crop")
mod <- lme4::lFormula(Cropinverts.vegdists ~ Cropinverts.geodists + (1 | pop1),
data = dat,
REML = FALSE)
##Update the sparse matrix and run the actual model
mod$reTrms$Zt <- ZZ
dfun <- do.call(lme4::mkLmerDevfun, mod)
opt <- lme4::optimizeLmer(dfun)
##Actual model
output <- (lme4::mkMerMod(environment(dfun),
opt,
mod$reTrms,
fr = mod$fr))
##Plot the model
cropslope <- data.frame(sjPlot::get_model_data(output, type = "eff", terms = "Cropinverts.geodists"))
##Other ###
Otherinverts.vegdists <- as.matrix(
vegdist(
Otherinverts[-c(1:30,587:592)], method = "jaccard"))[lower.tri(
as.matrix(
vegdist(
Otherinverts[-c(1:30, 587:592)], method = "jaccard")))]
Otherinverts.geodists <- as.matrix(
distm(
Otherinverts[,c("Longitude_dd", "Latitude_dd")]))[lower.tri(
as.matrix(
distm(Otherinverts[,c("Longitude_dd", "Latitude_dd")])))] / 1e+6
m <- 0.5 * (sqrt((8 * length(Otherinverts.geodists)) + 1) + 1)
Otherinverts.geodists <- Otherinverts.geodists[which(Otherinverts.geodists != -1)]
##Create the identifier for the random terms and itentity matrix
ID <- ResistanceGA::To.From.ID(m)
##Create the sparse matrix object for the MLPE model (identity matrix)
ZZ <- ZZ.mat(ID = ID)
##Join data together into a single dataframe
dat <- data.frame(ID, Otherinverts.geodists, Otherinverts.vegdists, LandUse = "Other")
mod <- lme4::lFormula(Otherinverts.vegdists ~ Otherinverts.geodists + (1 | pop1),
data = dat,
REML = FALSE)
##Update the sparse matrix and run the actual model
mod$reTrms$Zt <- ZZ
dfun <- do.call(lme4::mkLmerDevfun, mod)
opt <- lme4::optimizeLmer(dfun)
##Actual model
output <- (lme4::mkMerMod(environment(dfun),
opt,
mod$reTrms,
fr = mod$fr))
##Plot the model
Otherslope <- data.frame(sjPlot::get_model_data(output, type = "eff", terms = "Otherinverts.geodists"))
##Urban ###
Urbaninverts.vegdists <- as.matrix(
vegdist(
Urbaninverts[-c(1:30,587:592)], method = "jaccard"))[lower.tri(
as.matrix(
vegdist(
Urbaninverts[-c(1:30, 587:592)], method = "jaccard")))]
Urbaninverts.geodists <- as.matrix(
distm(
Urbaninverts[,c("Longitude_dd", "Latitude_dd")]))[lower.tri(
as.matrix(
distm(Urbaninverts[,c("Longitude_dd", "Latitude_dd")])))] / 1e+6
m <- 0.5 * (sqrt((8 * length(Urbaninverts.geodists)) + 1) + 1)
Urbaninverts.geodists <- Urbaninverts.geodists[which(Urbaninverts.geodists != -1)]
##Create the identifier for the random terms and itentity matrix
ID <- ResistanceGA::To.From.ID(m)
##Create the sparse matrix object for the MLPE model (identity matrix)
ZZ <- ZZ.mat(ID = ID)
##Join data together into a single dataframe
dat <- data.frame(ID, Urbaninverts.geodists, Urbaninverts.vegdists, LandUse = "Urban")
mod <- lme4::lFormula(Urbaninverts.vegdists ~ Urbaninverts.geodists + (1 | pop1),
data = dat,
REML = FALSE)
##Update the sparse matrix and run the actual model
mod$reTrms$Zt <- ZZ
dfun <- do.call(lme4::mkLmerDevfun, mod)
opt <- lme4::optimizeLmer(dfun)
##Actual model
output <- (lme4::mkMerMod(environment(dfun),
opt,
mod$reTrms,
fr = mod$fr))
##Plot the model
Urbanslope <- data.frame(sjPlot::get_model_data(output, type = "eff", terms = "Urbaninverts.geodists"))
#####
cropslope$group = "Crop"
Otherslope$group = "Other"
Urbanslope$group = "Urban"
slopes <- bind_rows(list(cropslope, Otherslope, Urbanslope))
ggplot(slopes, aes(x = x, y = predicted, color = group))+
geom_ribbon(aes(ymin = conf.low, ymax = conf.high, group = group, fill = group),
alpha = 0.25, color = NA)+
geom_line()
##Create the identity/sparse matrix function
ZZ.mat <- function(ID) {
Zl <-
lapply(c("pop1", "pop2"), function(nm)
Matrix::fac2sparse(ID[[nm]], "d", drop = FALSE))
ZZ <- Reduce("+", Zl[-1], Zl[[1]])
return(ZZ)
}
Cropinverts.vegdists <- as.matrix(
vegdist(
Cropinverts[-c(1:30,587:592)], method = "jaccard"))[lower.tri(
as.matrix(
vegdist(
Cropinverts[-c(1:30, 587:592)], method = "jaccard")))]
Cropinverts.geodists <- as.matrix(
distm(
Cropinverts[,c("Longitude_dd", "Latitude_dd")]))[lower.tri(
as.matrix(
distm(Cropinverts[,c("Longitude_dd", "Latitude_dd")])))] / 1e+6
m <- 0.5 * (sqrt((8 * length(Cropinverts.geodists)) + 1) + 1)
Cropinverts.geodists <- Cropinverts.geodists[which(Cropinverts.geodists != -1)]
##Create the identifier for the random terms and itentity matrix
ID <- ResistanceGA::To.From.ID(m)
##Create the sparse matrix object for the MLPE model (identity matrix)
ZZ <- ZZ.mat(ID = ID)
##Join data together into a single dataframe
dat <- data.frame(ID, Cropinverts.geodists, Cropinverts.vegdists, LandUse = "Crop")
mod <- lme4::lFormula(Cropinverts.vegdists ~ Cropinverts.geodists + (1 | pop1),
data = dat,
REML = FALSE)
##Update the sparse matrix and run the actual model
mod$reTrms$Zt <- ZZ
dfun <- do.call(lme4::mkLmerDevfun, mod)
opt <- lme4::optimizeLmer(dfun)
##Actual model
output <- (lme4::mkMerMod(environment(dfun),
opt,
mod$reTrms,
fr = mod$fr))
##Plot the model
cropslope <- data.frame(sjPlot::get_model_data(output, type = "eff", terms = "Cropinverts.geodists"))
##Other ###
Otherinverts.vegdists <- as.matrix(
vegdist(
Otherinverts[-c(1:30,587:592)], method = "jaccard"))[lower.tri(
as.matrix(
vegdist(
Otherinverts[-c(1:30, 587:592)], method = "jaccard")))]
Otherinverts.geodists <- as.matrix(
distm(
Otherinverts[,c("Longitude_dd", "Latitude_dd")]))[lower.tri(
as.matrix(
distm(Otherinverts[,c("Longitude_dd", "Latitude_dd")])))] / 1e+6
m <- 0.5 * (sqrt((8 * length(Otherinverts.geodists)) + 1) + 1)
Otherinverts.geodists <- Otherinverts.geodists[which(Otherinverts.geodists != -1)]
##Create the identifier for the random terms and itentity matrix
ID <- ResistanceGA::To.From.ID(m)
##Create the sparse matrix object for the MLPE model (identity matrix)
ZZ <- ZZ.mat(ID = ID)
##Join data together into a single dataframe
dat <- data.frame(ID, Otherinverts.geodists, Otherinverts.vegdists, LandUse = "Other")
mod <- lme4::lFormula(Otherinverts.vegdists ~ Otherinverts.geodists + (1 | pop1),
data = dat,
REML = FALSE)
##Update the sparse matrix and run the actual model
mod$reTrms$Zt <- ZZ
dfun <- do.call(lme4::mkLmerDevfun, mod)
opt <- lme4::optimizeLmer(dfun)
##Actual model
output <- (lme4::mkMerMod(environment(dfun),
opt,
mod$reTrms,
fr = mod$fr))
##Plot the model
Otherslope <- data.frame(sjPlot::get_model_data(output, type = "eff", terms = "Otherinverts.geodists"))
##Urban ###
Urbaninverts.vegdists <- as.matrix(
vegdist(
Urbaninverts[-c(1:30,587:592)], method = "jaccard"))[lower.tri(
as.matrix(
vegdist(
Urbaninverts[-c(1:30, 587:592)], method = "jaccard")))]
Urbaninverts.geodists <- as.matrix(
distm(
Urbaninverts[,c("Longitude_dd", "Latitude_dd")]))[lower.tri(
as.matrix(
distm(Urbaninverts[,c("Longitude_dd", "Latitude_dd")])))] / 1e+6
m <- 0.5 * (sqrt((8 * length(Urbaninverts.geodists)) + 1) + 1)
Urbaninverts.geodists <- Urbaninverts.geodists[which(Urbaninverts.geodists != -1)]
##Create the identifier for the random terms and itentity matrix
ID <- ResistanceGA::To.From.ID(m)
##Create the sparse matrix object for the MLPE model (identity matrix)
ZZ <- ZZ.mat(ID = ID)
##Join data together into a single dataframe
dat <- data.frame(ID, Urbaninverts.geodists, Urbaninverts.vegdists, LandUse = "Urban")
mod <- lme4::lFormula(Urbaninverts.vegdists ~ Urbaninverts.geodists + (1 | pop1),
data = dat,
REML = FALSE)
##Update the sparse matrix and run the actual model
mod$reTrms$Zt <- ZZ
dfun <- do.call(lme4::mkLmerDevfun, mod)
opt <- lme4::optimizeLmer(dfun)
##Actual model
output <- (lme4::mkMerMod(environment(dfun),
opt,
mod$reTrms,
fr = mod$fr))
##Plot the model
Urbanslope <- data.frame(sjPlot::get_model_data(output, type = "eff", terms = "Urbaninverts.geodists"))
#####
cropslope$group = "Crop"
Otherslope$group = "Other"
Urbanslope$group = "Urban"
slopes <- bind_rows(list(cropslope, Otherslope, Urbanslope))
ggplot(slopes, aes(x = x, y = predicted, color = group))+
geom_ribbon(aes(ymin = conf.low, ymax = conf.high, group = group, fill = group),
alpha = 0.25, color = NA)+
geom_line()
colnames(Cropinverts)
Cropinverts.vegdists <- as.matrix(
vegdist(
Cropinverts[,-c(1:34,559:564)], method = "jaccard"))[lower.tri(
as.matrix(
vegdist(
Cropinverts[,-c(1:34,559:564)], method = "jaccard")))]
Cropinverts.geodists <- as.matrix(
distm(
Cropinverts[,c("Longitude_dd", "Latitude_dd")]))[lower.tri(
as.matrix(
distm(Cropinverts[,c("Longitude_dd", "Latitude_dd")])))] / 1e+6
m <- 0.5 * (sqrt((8 * length(Cropinverts.geodists)) + 1) + 1)
Cropinverts.geodists <- Cropinverts.geodists[which(Cropinverts.geodists != -1)]
##Create the identifier for the random terms and itentity matrix
ID <- ResistanceGA::To.From.ID(m)
##Create the sparse matrix object for the MLPE model (identity matrix)
ZZ <- ZZ.mat(ID = ID)
##Join data together into a single dataframe
dat <- data.frame(ID, Cropinverts.geodists, Cropinverts.vegdists, LandUse = "Crop")
mod <- lme4::lFormula(Cropinverts.vegdists ~ Cropinverts.geodists + (1 | pop1),
data = dat,
REML = FALSE)
##Update the sparse matrix and run the actual model
mod$reTrms$Zt <- ZZ
dfun <- do.call(lme4::mkLmerDevfun, mod)
opt <- lme4::optimizeLmer(dfun)
##Actual model
output <- (lme4::mkMerMod(environment(dfun),
opt,
mod$reTrms,
fr = mod$fr))
##Plot the model
cropslope <- data.frame(sjPlot::get_model_data(output, type = "eff", terms = "Cropinverts.geodists"))
Otherinverts.vegdists <- as.matrix(
vegdist(
Otherinverts[,-c(1:34,559:564)], method = "jaccard"))[lower.tri(
as.matrix(
vegdist(
Otherinverts[,-c(1:34,559:564)], method = "jaccard")))]
Otherinverts.geodists <- as.matrix(
distm(
Otherinverts[,c("Longitude_dd", "Latitude_dd")]))[lower.tri(
as.matrix(
distm(Otherinverts[,c("Longitude_dd", "Latitude_dd")])))] / 1e+6
m <- 0.5 * (sqrt((8 * length(Otherinverts.geodists)) + 1) + 1)
Otherinverts.geodists <- Otherinverts.geodists[which(Otherinverts.geodists != -1)]
##Create the identifier for the random terms and itentity matrix
ID <- ResistanceGA::To.From.ID(m)
##Create the sparse matrix object for the MLPE model (identity matrix)
ZZ <- ZZ.mat(ID = ID)
##Join data together into a single dataframe
dat <- data.frame(ID, Otherinverts.geodists, Otherinverts.vegdists, LandUse = "Other")
mod <- lme4::lFormula(Otherinverts.vegdists ~ Otherinverts.geodists + (1 | pop1),
data = dat,
REML = FALSE)
##Update the sparse matrix and run the actual model
mod$reTrms$Zt <- ZZ
dfun <- do.call(lme4::mkLmerDevfun, mod)
opt <- lme4::optimizeLmer(dfun)
##Actual model
output <- (lme4::mkMerMod(environment(dfun),
opt,
mod$reTrms,
fr = mod$fr))
##Plot the model
Otherslope <- data.frame(sjPlot::get_model_data(output, type = "eff", terms = "Otherinverts.geodists"))
##Urban ###
Urbaninverts.vegdists <- as.matrix(
vegdist(
Urbaninverts[,-c(1:34,559:564)], method = "jaccard"))[lower.tri(
as.matrix(
vegdist(
Urbaninverts[,-c(1:34,559:564)], method = "jaccard")))]
Urbaninverts.geodists <- as.matrix(
distm(
Urbaninverts[,c("Longitude_dd", "Latitude_dd")]))[lower.tri(
as.matrix(
distm(Urbaninverts[,c("Longitude_dd", "Latitude_dd")])))] / 1e+6
m <- 0.5 * (sqrt((8 * length(Urbaninverts.geodists)) + 1) + 1)
Urbaninverts.geodists <- Urbaninverts.geodists[which(Urbaninverts.geodists != -1)]
##Create the identifier for the random terms and itentity matrix
ID <- ResistanceGA::To.From.ID(m)
##Create the sparse matrix object for the MLPE model (identity matrix)
ZZ <- ZZ.mat(ID = ID)
##Join data together into a single dataframe
dat <- data.frame(ID, Urbaninverts.geodists, Urbaninverts.vegdists, LandUse = "Urban")
mod <- lme4::lFormula(Urbaninverts.vegdists ~ Urbaninverts.geodists + (1 | pop1),
data = dat,
REML = FALSE)
##Update the sparse matrix and run the actual model
mod$reTrms$Zt <- ZZ
dfun <- do.call(lme4::mkLmerDevfun, mod)
opt <- lme4::optimizeLmer(dfun)
##Actual model
output <- (lme4::mkMerMod(environment(dfun),
opt,
mod$reTrms,
fr = mod$fr))
##Plot the model
Urbanslope <- data.frame(sjPlot::get_model_data(output, type = "eff", terms = "Urbaninverts.geodists"))
#####
cropslope$group = "Crop"
Otherslope$group = "Other"
Urbanslope$group = "Urban"
slopes <- bind_rows(list(cropslope, Otherslope, Urbanslope))
ggplot(slopes, aes(x = x, y = predicted, color = group))+
geom_ribbon(aes(ymin = conf.low, ymax = conf.high, group = group, fill = group),
alpha = 0.25, color = NA)+
geom_line()
dat
ggplot(slopes, aes(x = x, y = predicted, color = group))+
geom_point(data = dat, aes(x = Urbaninverts.geodists, y = Urbaninverts.vegdists),
shape = 21, fill = NA)+
geom_ribbon(aes(ymin = conf.low, ymax = conf.high, group = group, fill = group),
alpha = 0.25, color = NA)+
geom_line()
ggplot(slopes, aes(x = x, y = predicted))+
geom_point(data = dat, aes(x = Urbaninverts.geodists, y = Urbaninverts.vegdists),
shape = 21, fill = NA)+
geom_ribbon(aes(ymin = conf.low, ymax = conf.high, group = group, fill = group,
color = group),
alpha = 0.25, color = NA)+
geom_line(aes(color = group))
performance::r2(output)
inverts_NAWQA <- datInv %>%
left_join(invert_NLCD)
inverts_NAWQA$NLCDGroup <- ifelse(inverts_NAWQA$PctCrop_Cat > 49.9,
"Crop",
ifelse(inverts_NAWQA$PctUrb_Cat > 49.9,
"Urban",
ifelse(inverts_NAWQA$PctFst_Cat > 49.9,
"Forest",
"Other")))
inverts_NAWQA <- inverts_NAWQA %>%
filter(!is.na(NLCDGroup)) %>%
filter(CollectionYear == "2013")
split(inverts_NAWQA, inverts_NAWQA$NLCDGroup)
Cropinverts <- split(inverts_NAWQA, inverts_NAWQA$NLCDGroup)[[1]]
Otherinverts <- split(inverts_NAWQA, inverts_NAWQA$NLCDGroup)[[2]]
Urbaninverts <- split(inverts_NAWQA, inverts_NAWQA$NLCDGroup)[[4]]
Cropinverts.vegdists <- as.matrix(
vegdist(
Cropinverts[,-c(1:34,559:564)], method = "jaccard"))[lower.tri(
as.matrix(
vegdist(
Cropinverts[,-c(1:34,559:564)], method = "jaccard")))]
Cropinverts.geodists <- as.matrix(
distm(
Cropinverts[,c("Longitude_dd", "Latitude_dd")]))[lower.tri(
as.matrix(
distm(Cropinverts[,c("Longitude_dd", "Latitude_dd")])))] / 1e+6
m <- 0.5 * (sqrt((8 * length(Cropinverts.geodists)) + 1) + 1)
Cropinverts.geodists <- Cropinverts.geodists[which(Cropinverts.geodists != -1)]
##Create the identifier for the random terms and itentity matrix
ID <- ResistanceGA::To.From.ID(m)
##Create the sparse matrix object for the MLPE model (identity matrix)
ZZ <- ZZ.mat(ID = ID)
##Join data together into a single dataframe
dat <- data.frame(ID, Cropinverts.geodists, Cropinverts.vegdists, LandUse = "Crop")
mod <- lme4::lFormula(Cropinverts.vegdists ~ Cropinverts.geodists + (1 | pop1),
data = dat,
REML = FALSE)
##Update the sparse matrix and run the actual model
mod$reTrms$Zt <- ZZ
dfun <- do.call(lme4::mkLmerDevfun, mod)
opt <- lme4::optimizeLmer(dfun)
##Actual model
output <- (lme4::mkMerMod(environment(dfun),
opt,
mod$reTrms,
fr = mod$fr))
##Plot the model
cropslope <- data.frame(sjPlot::get_model_data(output, type = "eff", terms = "Cropinverts.geodists"))
##Other ###
Otherinverts.vegdists <- as.matrix(
vegdist(
Otherinverts[,-c(1:34,559:564)], method = "jaccard"))[lower.tri(
as.matrix(
vegdist(
Otherinverts[,-c(1:34,559:564)], method = "jaccard")))]
Otherinverts.geodists <- as.matrix(
distm(
Otherinverts[,c("Longitude_dd", "Latitude_dd")]))[lower.tri(
as.matrix(
distm(Otherinverts[,c("Longitude_dd", "Latitude_dd")])))] / 1e+6
m <- 0.5 * (sqrt((8 * length(Otherinverts.geodists)) + 1) + 1)
Otherinverts.geodists <- Otherinverts.geodists[which(Otherinverts.geodists != -1)]
##Create the identifier for the random terms and itentity matrix
ID <- ResistanceGA::To.From.ID(m)
##Create the sparse matrix object for the MLPE model (identity matrix)
ZZ <- ZZ.mat(ID = ID)
##Join data together into a single dataframe
dat <- data.frame(ID, Otherinverts.geodists, Otherinverts.vegdists, LandUse = "Other")
mod <- lme4::lFormula(Otherinverts.vegdists ~ Otherinverts.geodists + (1 | pop1),
data = dat,
REML = FALSE)
##Update the sparse matrix and run the actual model
mod$reTrms$Zt <- ZZ
dfun <- do.call(lme4::mkLmerDevfun, mod)
opt <- lme4::optimizeLmer(dfun)
##Actual model
output <- (lme4::mkMerMod(environment(dfun),
opt,
mod$reTrms,
fr = mod$fr))
##Plot the model
Otherslope <- data.frame(sjPlot::get_model_data(output, type = "eff", terms = "Otherinverts.geodists"))
##Urban ###
Urbaninverts.vegdists <- as.matrix(
vegdist(
Urbaninverts[,-c(1:34,559:564)], method = "jaccard"))[lower.tri(
as.matrix(
vegdist(
Urbaninverts[,-c(1:34,559:564)], method = "jaccard")))]
Urbaninverts.geodists <- as.matrix(
distm(
Urbaninverts[,c("Longitude_dd", "Latitude_dd")]))[lower.tri(
as.matrix(
distm(Urbaninverts[,c("Longitude_dd", "Latitude_dd")])))] / 1e+6
m <- 0.5 * (sqrt((8 * length(Urbaninverts.geodists)) + 1) + 1)
Urbaninverts.geodists <- Urbaninverts.geodists[which(Urbaninverts.geodists != -1)]
##Create the identifier for the random terms and itentity matrix
ID <- ResistanceGA::To.From.ID(m)
##Create the sparse matrix object for the MLPE model (identity matrix)
ZZ <- ZZ.mat(ID = ID)
##Join data together into a single dataframe
dat <- data.frame(ID, Urbaninverts.geodists, Urbaninverts.vegdists, LandUse = "Urban")
mod <- lme4::lFormula(Urbaninverts.vegdists ~ Urbaninverts.geodists + (1 | pop1),
data = dat,
REML = FALSE)
##Update the sparse matrix and run the actual model
mod$reTrms$Zt <- ZZ
dfun <- do.call(lme4::mkLmerDevfun, mod)
opt <- lme4::optimizeLmer(dfun)
##Actual model
output <- (lme4::mkMerMod(environment(dfun),
opt,
mod$reTrms,
fr = mod$fr))
##Plot the model
Urbanslope <- data.frame(sjPlot::get_model_data(output, type = "eff", terms = "Urbaninverts.geodists"))
#####
cropslope$group = "Crop"
Otherslope$group = "Other"
Urbanslope$group = "Urban"
slopes <- bind_rows(list(cropslope, Otherslope, Urbanslope))
ggplot(slopes, aes(x = x, y = predicted))+
geom_point(data = dat, aes(x = Urbaninverts.geodists, y = Urbaninverts.vegdists),
shape = 21, fill = NA)+
geom_ribbon(aes(ymin = conf.low, ymax = conf.high, group = group, fill = group,
color = group),
alpha = 0.25, color = NA)+
geom_line(aes(color = group))
performance::r2(output)
load("~/Dokumente/Side_projects/StreamData_package/StreamData/R/sysdata.rda")
