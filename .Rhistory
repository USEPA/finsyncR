Inverts <- Inverts %>%
dplyr::filter(ProjectLabel %in% (Project %>%
dplyr::filter(Program %in% database) %>%
dplyr::distinct(ProjectLabel,
.keep_all = FALSE))[ , "ProjectLabel"])
SamplingRatio_SamplerType <- StreamData:::.SamplingRatio_SamplerType
Inverts <- dplyr::left_join(Inverts,
SamplingRatio_SamplerType,
by = "LabRecordID")
### Have to sum invertebrate abundance of duplicate species entries for
### all samplers
## Folsom samplers split the sample repeatedly, and count ***ALL*** individuals
## towards the abundance measures
## So, this first step in determining 'Abundance' is to sum (e.g., collapse) all
## entries for a given species at each collection site for a single
## 'Abundance' measure
## "IRTH" == "Invertebrate Richest Taxa Habitat" theoretically supports the faunistically
## richest invertebrate community and is typically represented by a
## coarse-grained riffle or a woody snag. The semi-quantitative RTH sample
## consists of a series of discrete collections (for example, five Slack
## samples or 10 woody snag sections) that are processed and combined
## into a single composited sample.
## 'FieldComponent' "M" refers to the "Main-body sample"
## Convert 'CollectionDate' to date format from factor
## Added in a distinct 'SIDNO' (sample number) x 'SiteNumber' x 'CollectionDate'
## identifier to each row, Easier to sort on this later
## Based on Devin Jones's notes, the biodata data dictionary, and my
## understanding of the datasets, I believe it is best to go with
## "PublishedTaxonName" as the basis for the "SampleGrouping".
Inverts <- Inverts %>%
dplyr::filter(SampleTypeCode %in% c("IRTH", "BERW")) %>%
dplyr::filter(FieldComponent == "M") %>%
dplyr::mutate(CollectionDate = as.Date(CollectionDate,
format = "%m/%d/%Y"),
Identifier = paste(SIDNO,
SiteNumber,
CollectionDate, sep = "_"),
SampleGrouping = paste(SIDNO,
SiteNumber,
CollectionDate,
PublishedTaxonName,
Lifestage,
sep = "_" ))
### *** It is at this stage, we COULD filter for a given 'Lifestage'
### ( (blank), L [larvae], P [pupae], A [adult]);
### we will leave in ALL 'Lifestage' at this moment***
### *** We will HAVE TO include 'Lifestage' within our unique identifiers for
### each site, as not to lose this level of detail for analyses***
## We now have to clean the data for sites that used a Folsom Sampler that
## identified invertebrates with multiple 'LabSubsamplingRatio'
### IF n_distinct(LabSubsamplingRatio) == 1, then the sample was either fully
### counted or only the subsample was entered (WHICH IS WHAT WE WANT)
### IF n_distinct(LabSubsamplingRatio) >= 2, then the sample was split multiple
### times (FS), or includes "lab large rare" individuals (e.g., species entry
### will include 1:1 and other subsampled ratio) on a Gridded tray
## So we first filter all sites for those with >= 2 'LabSubsamplingRatio'
Invert_MixedRatios <- Inverts %>%
dplyr::group_by(Identifier) %>%
dplyr::filter(n_distinct(LabSubsamplingRatio) >= 2) %>%
dplyr::ungroup()
Invert_SingleRatios <- suppressMessages({dplyr::anti_join(Inverts, Invert_MixedRatios) %>%
dplyr::mutate(DatasetPortion = "SingleRatios")})
SingleRatio_Duplicates <-
Invert_SingleRatios[duplicated(Invert_SingleRatios$SampleGrouping) |
duplicated(Invert_SingleRatios$SampleGrouping,
fromLast = TRUE), ] %>%
dplyr::group_by(SampleGrouping) %>%
dplyr::mutate(LabRecordIDs = paste(LabRecordID, collapse = "_"),
Ratios = paste(Ratio, collapse = "_")) %>%
dplyr::ungroup()
SumSingleRatioData = suppressWarnings({SingleRatio_Duplicates %>%
dplyr::group_by(SampleGrouping) %>%
dplyr::mutate(SummedAbundance = sum(Abundance),
SummedRawCount = sum(RawCount)) %>%
dplyr::ungroup() %>%
dplyr::group_by(SampleGrouping) %>%
dplyr::slice(1) %>%
dplyr::ungroup() %>%
dplyr::mutate(Abundance = SummedAbundance,
Density_m2 = as.numeric("NA"),
AdjRawCount = as.numeric("NA"),
RawCount =SummedRawCount,
TotAreaSampled_m2 = as.numeric("NA"),
FieldSplitRatio = as.numeric("NA"),
Note = "Abundance measure is summed 'Abundance' across multiple inputs
(see 'LabRecordsIDs'); Likely due to changed identification
(e.g., BenchNotes)",
DatasetPortion = "SummedAbundance_SingleRatios") %>%
dplyr::select(-SummedAbundance, -SummedRawCount)})
Corrected_SingleRatios <- suppressMessages({dplyr::bind_rows((dplyr::anti_join(Invert_SingleRatios,
SingleRatio_Duplicates) %>%
dplyr::mutate(DatasetPortion =
"NonDuplicate_SingleRatio")),
SumSingleRatioData)})
### For those with "1:1 FS + Grid ratio", a "lab-large rare" individual was
### recorded following a gridded tray subsample
### We have to remove that biased individual(s) from the abundance data,
### as they are identified and recorded from the the remaining sample outside
### the selected number of gridded cells
### Permits us to examine those sites with different sampler types
### (e.g., n_distinct(SamplerType) == 2, which is 1:1 FS + Grid)
### Extracts the portion of the site sample that was correctly sampled
### as part of the gridded tray
### *** THIS DATASET IS THE CORRECT GRIDDED SUBSAMPLE INFORMATION WHICH NEEDS
### TO BE COMBINED WITH SUMMED FOLSOM SAMPLER DATA***
Invert_MixedRatios_GridsAndFS <- Invert_MixedRatios %>%
dplyr::group_by(Identifier) %>%
dplyr::filter(dplyr::n_distinct(SamplerType) == 2) %>%
dplyr::ungroup()
Invert_MixedSamplerType_GridOnly_LLRRemoved <- Invert_MixedRatios_GridsAndFS %>%
dplyr::group_by(Identifier) %>%
dplyr::filter(SamplerType == "Grid") %>%
dplyr::ungroup() %>%
dplyr::mutate(DatasetPortion = "Grid_LRRRemoved")
## Now that we have all the gridded portion of samples
## we can check the subsampled gridded samples for any duplicates
Gridded_LLRRemoved_Duplicates <-
Invert_MixedSamplerType_GridOnly_LLRRemoved[
duplicated(Invert_MixedSamplerType_GridOnly_LLRRemoved$SampleGrouping) |
duplicated(Invert_MixedSamplerType_GridOnly_LLRRemoved$SampleGrouping,
fromLast = TRUE), ]
## Add identifiers so we can see which columns were collapsed
### Now that we have all duplicated 'SingleRatio' samples,
### we have to combine the 'Abundance' measures
### (per communication with Scott Grotheer 6-17-19: 'BenchNotes' of duplicated
### entries indicate changed identification/sample type of specimens;
### can combine either 'Abundance' or 'RawCount')
### In order to know which samples are being grouped, we first need to identify
### which 'LabRecordID' are included in the summed 'Abundance' values
### This enables us to track which samples would be included in this measure
### We can also add the unique 'Ratio' included in the duplicates
### (which should be the same for all duplicates)
### Now we can the 'LabRecord_Labels' and 'Ratio_Labels' to the duplicated data
SumGridLLRData <- Gridded_LLRRemoved_Duplicates %>%
dplyr::group_by(SampleGrouping) %>%
dplyr::mutate(LabRecordIDs = paste(LabRecordID, collapse = "_"),
Ratios = paste(Ratio, collapse = "_")) %>%
dplyr::ungroup() %>%
dplyr::mutate(DatasetPortion = "Gridded_LLRRemoved_Duplicates")
## Moving the numeric values of each row to the end of the dataset to better
## visualize the changes we're making
## Removed columns from the dataset that we have created values for
## (e.g., LabRecord_Labels, Ratio_Labels)
## or served their purpose (e.g., Proprietary, SamplerRatio_SamplerType)
## Groups the unique 'SampleGrouping' and sums the 'Abundance' data for each
## Adds the 'SummedAbundance' value to each row based on the 'SampleGrouping' ID
## Removes the first row of each unique 'SampleGrouping'; Takes a single row,
## which we will then place the 'SummedAbundance' value in
## To not overwrite the previous step so we can always modify later
## Replacing the 'Abundance' value with the 'SummedAbundance' value
SumGridLLRData2 = suppressWarnings({SumGridLLRData %>%
dplyr::select(-"LabRecordID", -"NWQLSubsamplingCode", -"Ratio",
-"X", -"NumbEntries") %>%
dplyr::group_by(SampleGrouping) %>%
dplyr::mutate(SummedAbundance = sum(Abundance),
SummedRawCount = sum(RawCount)) %>%
dplyr::ungroup() %>%
dplyr::group_by(SampleGrouping) %>%
dplyr::slice(1) %>%
dplyr::ungroup() %>%
dplyr::mutate(Abundance = SummedAbundance,
Density_m2 = as.numeric("NA"),
AdjRawCount = as.numeric("NA"),
RawCount = SummedRawCount,
TotAreaSampled_m2 = as.numeric("NA"),
FieldSplitRatio = as.numeric("NA"),
Note = "Abundance measure is summed 'Abundance' across multiple inputs
(see 'LabRecordsIDs'); Likely due to changed identification
(e.g., BenchNotes)",
DatasetPortion = "SummedAbundance_Gridded_LLRRemoved") %>%
dplyr::select(-SummedAbundance, -SummedRawCount)})
## Now that we have the corrected summed values for the
## 'Gridded_LLRRemoved_Duplicates', we need to add these rows to the
## non-duplicated rows within the 'SingleRatio' portions
Corrected_Gridded_LLRRemoved <- suppressMessages({dplyr::bind_rows(
(dplyr::anti_join(Invert_MixedSamplerType_GridOnly_LLRRemoved,
Gridded_LLRRemoved_Duplicates) %>%
dplyr::mutate(DatasetPortion =
"NonDuplicate_Gridded_LLRRemoved")),
SumGridLLRData2)})
## We now have to clean the data for sites that used a Folsom Sampler that
## identified invertebrates with multiple 'LabSubsamplingRatio'
### IF n_distinct(LabSubsamplingRatio) == 1, then the sample was either
###  fully counted or only the subsample was entered (WHICH IS WHAT WE WANT)
### IF n_distinct(LabSubsamplingRatio) >= 2, then the sample was split multiple
###  times (FS), or includes "lab large rare" individuals (e.g., species entry
###  will include 1:1 and other subsampled ratio) on a Gridded tray
### So we first filter all sites for those with >= 2 'LabSubsamplingRatio'
### (duplicate STEP 6 action)
## Now that we have these ***FOLSOM SAMPLER ONLY*** samples,
## we can combine the 'Abundance' data for duplicate species entries
### We first have to create a unique variable that encompasses
### each site-by-collection-date-by-biota-by-life-stage combination
Invert_MixedRatios_FolsomSamplerOnly_AntiJoin <- suppressMessages({Inverts %>%
dplyr::group_by(SIDNO, SiteNumber, CollectionDate) %>%
dplyr::filter(n_distinct(LabSubsamplingRatio) >= 2) %>%
dplyr::anti_join(Invert_MixedRatios_GridsAndFS)})
## Now we can reduce the dataset to duplicate entries
## We will include both "from the first duplicate" and
## "from the last duplicate" to bookend each duplicate entry
Invert_MixedRatios_Folsom_AntiJoin_Duplicates <-
Invert_MixedRatios_FolsomSamplerOnly_AntiJoin[
duplicated(Invert_MixedRatios_FolsomSamplerOnly_AntiJoin$SampleGrouping)|
duplicated(Invert_MixedRatios_FolsomSamplerOnly_AntiJoin$SampleGrouping,
fromLast = TRUE), ]
## Now that we have all duplicated 'FS' samples, we have to combine the
## 'Abundance' measures (as per communication with Scott Grotheer 5-3-19:
## "always is a pretty BIG word, but I think that (summing 'Abundance')
## is a safe way to go")
### In order to know which samples are being grouped, we first need to
### identify which 'LabRecordID' are included in the summed 'Abundance'
### This enables us to track samples to be included in this summed measure
Invert_MixedRatios_Folsom_AntiJoin_Duplicates <-
Invert_MixedRatios_Folsom_AntiJoin_Duplicates  %>%
dplyr::group_by(SampleGrouping) %>%
dplyr::mutate(LabRecordIDs = paste(LabRecordID, collapse = "_"),
Ratios = paste(Ratio, collapse = "_")) %>%
dplyr::ungroup()
## Moving the numeric values of each row to the end of the dataset to better
## visualize the changes we're making
## Removed columns from the dataset that we have created values for
## (e.g., LabRecord_Labels, Ratio_Labels) or served their purpose
## (e.g., Proprietary, SamplerRatio_SamplerType)
## Groups the unique 'SampleGrouping' and sums the 'Abundance' data
## for each group of values
## Adds the 'SummedAbundance' value to each row based on the 'SampleGrouping' ID
## Removes the first row of each unique 'SampleGrouping';
## Takes a single row, which we will then place the 'SummedAbundance' value in
SumData <- suppressWarnings({Invert_MixedRatios_Folsom_AntiJoin_Duplicates %>%
dplyr::select(-"LabRecordID", -"NWQLSubsamplingCode", -"Ratio",
-"X", -"NumbEntries") %>%
dplyr::group_by(SampleGrouping) %>%
dplyr::mutate(SummedAbundance = sum(Abundance),
SummedRawCount = sum(RawCount)) %>%
dplyr::ungroup() %>%
dplyr::group_by(SampleGrouping) %>%
dplyr::slice(1) %>%
dplyr::ungroup() %>%
dplyr::mutate(Abundance = SummedAbundance,
Density_m2 = as.numeric("NA"),
AdjRawCount = as.numeric("NA"),
RawCount = SummedRawCount,
TotAreaSampled_m2 = as.numeric("NA"),
FieldSplitRatio = as.numeric("NA"),
Note = "Abundance measure is summed 'Abundance' across multiple
folsom sampler inputs (see 'LabRecordsIDs')",
DatasetPortion = "SummedAbundance_FolsomSampler") %>%
dplyr::select(-SummedAbundance, -SummedRawCount)})
Corrected_MixedRatios_FolsomSamplerOnly <- suppressMessages({dplyr::bind_rows((
dplyr::anti_join(Invert_MixedRatios_FolsomSamplerOnly_AntiJoin,
Invert_MixedRatios_Folsom_AntiJoin_Duplicates,
by = "SampleGrouping") %>%
dplyr::mutate(DatasetPortion = "NonDuplicate_FolsomSampler")),
SumData)})
TotalRows <- do.call(dplyr::bind_rows,list(Corrected_MixedRatios_FolsomSamplerOnly,
Corrected_Gridded_LLRRemoved,
Corrected_SingleRatios))
###The above code, hypothetically, could be removed to a separate, hidden
## function. Would take a little bit of work, but could easily be done.
###At this point, we need to join information on stream, site, and sample (?)
## information
### Need to get sampled area from the Sample dataset
###Then, we need to pivot_wider, filter based on taxon level, remove excess
## columns, and change the data type
###Can use code from the "getAlgaeData" function to work on this portion.
###Need to add a section for Lifestage "T/F"; if true count separately, if false count together
invertsamp = utils::read.csv(system.file("extdata",
"20201217.0749.InvertSamp.csv",
package = "StreamData"),
colClasses = c("SiteNumber" = "character"),
stringsAsFactors = FALSE) %>%
dplyr::rename(SIDNO = grep("SIDNO", names(.))) %>%
dplyr::select(SIDNO,
SiteNumber,
AreaSampTot_m2,
GeomorphicChannelUnit,
ChannelBoundaries,
ChannelFeatures)
invertsampinv = utils::read.csv(system.file("extdata",
"20201217.0749.SampleInv.csv",
package = "StreamData"),
colClasses = c("SiteNumber" = "character"),
stringsAsFactors = FALSE) %>%
dplyr::rename(SIDNO = grep("SIDNO", names(.))) %>%
dplyr::select(SIDNO,
ReplicateType)
invertsite = utils::read.csv(system.file("extdata",
"20201217.0749.SiteInfo.csv",
package = "StreamData"),
colClasses = c("SiteNumber" = "character"),
stringsAsFactors = FALSE) %>%
dplyr::select(SiteNumber,
Latitude_dd,
Longitude_dd,
CoordinateDatum,
HUCCode,
DrainageArea_mi2,
SiteTypeName,
CountyFIPSCode,
StateFIPSCode)
invertsampinfo = dplyr::left_join(dplyr::left_join(invertsamp,
invertsampinv,
by = "SIDNO"),
invertsite,
by = "SiteNumber") %>%
dplyr::select(-SiteNumber) %>%
dplyr::mutate(CountyFIPSCode = sprintf("%03d", CountyFIPSCode),
StateFIPSCode = sprintf("%02d", StateFIPSCode))
TotalRows = dplyr::left_join(TotalRows,
invertsampinfo,
by = "SIDNO")
if(abunMeasure == "abundance"){
abunMeasure = "Abundance"
notAbun <- "Density_m2"
} else {
notAbun <- "Abundance"
abunMeasure <- "Density_m2"}
mycols = StreamData:::.TaxLevCols_Inverts[[which(names(StreamData:::.TaxLevCols_Inverts) == taxonLevel)]]$mycols
taxcols = StreamData:::.TaxLevCols_Inverts[[which(names(StreamData:::.TaxLevCols_Inverts) == taxonLevel)]]$taxcols
##MIKE NOTE BELOW
###NOTE: NEED TO MOVE THIS AFTER THE RANDOM SAMPLING, BECAUSE IT IS CAUSING SAMPLES TO BE DROPPED
##THIS COULD AFFECT SOME THINGS, BUT MIGHT BE REALLY EASY
if(isTRUE(rarefy)) {
TotalRows = TotalRows %>%
dplyr::group_by(SIDNO) %>%
dplyr::mutate(indcounted = sum(RawCount)) %>%
dplyr::filter(indcounted > 299) %>%
dplyr::select(-indcounted) %>%
dplyr::ungroup() %>%
dplyr::group_by(SIDNO) %>%
dplyr::slice(rep(1:n(), times=RawCount)) %>%
dplyr::sample_n(size = 300) %>%
dplyr::group_by(SIDNO, PublishedTaxonName) %>%
dplyr::slice(1) %>%
dplyr::ungroup()
} else {}
##SLR - ADD OPTIONS TO 1) GROUP PROBLEMATIC IDENTIFICATIONS OR 2) THROW OUT PROBLEMATIC OBSERVATION WITH MISSING SPP DATA
#create variable taxonFix = none, lump, remove
#none = no change, lump = lump genera through time, remove = remove observation only if spp. level ID does not exist
if(taxonFix == "none"){
}else if(taxonFix == "lump"){
#create bench genus in TotalRows
TotalRows <- TotalRows %>%
dplyr::mutate(BenchGenus = as.character(gsub( " .*$", "", BenchTaxonName)))
#If bench genera that are one of bench genera in clust_labels, rename the Genus with the lump label from clust_labels
#else, keep the original Genus label
TotalRows$Genus <- ifelse(TotalRows$BenchGenus %in% StreamData:::.clust_labels$genus,
StreamData:::.clust_labels$lump[match(TotalRows$BenchGenus,StreamData:::.clust_labels$genus)],
TotalRows$Genus)
TotalRows <- TotalRows %>%
dplyr::select(-BenchGenus)
}else if(taxonFix == "remove"){
#filter out rows that have bench genus from problem list & no species ID
TotalRows <- TotalRows %>%
dplyr::filter(!(Genus %in% StreamData:::.clust_labels$genus & PublishedTaxonNameLevel == "Genus"))
}
if(isTRUE(lifestage)) {
#Lifestage-taxon combinations
invert_comms1 = TotalRows %>%
dplyr::filter(PublishedTaxonNameLevel %in% taxcols) %>%
dplyr::filter_at(vars(all_of(taxonLevel)), any_vars(. != "")) %>%
tidyr::unite(UNIQUEID, c(SIDNO, all_of(taxonLevel), Lifestage), sep = "_", remove = FALSE) %>%
dplyr::group_by(UNIQUEID) %>%
dplyr::mutate(Abundance = sum(Abundance)) %>%
dplyr::slice(1) %>%
dplyr::ungroup() %>%
dplyr::mutate(Density_m2 = ifelse(is.na(AreaSampTot_m2),
NA,
Abundance / AreaSampTot_m2)) %>%
dplyr::select(-any_of(c("LabOrderID", "LabRecordID", "FieldComponent",
"LabComponent", "LabProcName",
"TaxonomicResultReviewStatus",
"PublishedSortOrder", "BioDataTaxonName", "BioDataShortName",
"BenchTaxonName", "BenchTaxonNameReferenceCode",
"AdjRawCount", "RawCount",
"FieldSplitRatio", "LabSubsamplingRatio", "UniqueTaxonFlag",
"TargetLevelNotReachedReason", "Artifact", "BenchNotes",
"TaxonRecordSource", "IdentificationDate",
"VerificationEntity", "VerificationDate", "CurationEntity",
"CurationDate", 'ITIS_TSN', "ITIS_MatchCode", "PublishedTaxonName",
"PublishedTaxonNameAuthority", "ScientificName",
"TaxonVersionNumber", "NWQLSubsamplingCode",
"Ratio", 'X', "NumbEntries", "SampleGrouping", "LabRecordIDs",
"Ratios", "Note", "UNIQUEID", "PublishedTaxonNameLevel",
"SamplerType", "DatasetPortion", "TotAreaSampled_m2"))) %>%
dplyr::select(-any_of(mycols),
-any_of(notAbun)) %>%
tidyr::unite(Taxon_Life, c(all_of(taxonLevel), Lifestage), sep = "_") %>%
tidyr::pivot_wider(names_from = all_of(Taxon_Life),
names_prefix = "tax_",
values_from = all_of(abunMeasure),
values_fill = 0)
} else {
#All species are one
invert_comms1 = TotalRows %>%
dplyr::filter(PublishedTaxonNameLevel %in% taxcols) %>%
dplyr::filter_at(vars(all_of(taxonLevel)), any_vars(. != "")) %>%
tidyr::unite(UNIQUEID, c(SIDNO, all_of(taxonLevel)), sep = "_", remove = FALSE) %>%
dplyr::group_by(UNIQUEID) %>%
dplyr::mutate(Abundance = sum(Abundance)) %>%
dplyr::slice(1) %>%
dplyr::ungroup() %>%
dplyr::mutate(Density_m2 = ifelse(is.na(AreaSampTot_m2),
NA,
Abundance / AreaSampTot_m2)) %>%
dplyr::select(-tidyselect::any_of(c("LabOrderID", "LabRecordID", "FieldComponent",
"LabComponent", "LabProcName",
"TaxonomicResultReviewStatus",
"PublishedSortOrder", "BioDataTaxonName", "BioDataShortName",
"BenchTaxonName", "BenchTaxonNameReferenceCode",
"AdjRawCount", "RawCount",
"FieldSplitRatio", "LabSubsamplingRatio", "UniqueTaxonFlag",
"TargetLevelNotReachedReason", "Artifact", "BenchNotes",
"TaxonRecordSource", "IdentificationDate",
"VerificationEntity", "VerificationDate", "CurationEntity",
"CurationDate", 'ITIS_TSN', "ITIS_MatchCode", "PublishedTaxonName",
"PublishedTaxonNameAuthority", "ScientificName",
"TaxonVersionNumber", "NWQLSubsamplingCode",
"Ratio", 'X', "NumbEntries", "SampleGrouping", "LabRecordIDs",
"Ratios", "Note", "Lifestage", "UNIQUEID", "PublishedTaxonNameLevel",
"SamplerType", "DatasetPortion", "TotAreaSampled_m2"))) %>%
dplyr::select(-tidyselect::any_of(mycols)) %>%
dplyr::select(-tidyselect::any_of(notAbun)) %>%
tidyr::pivot_wider(names_from = all_of(taxonLevel),
names_prefix = "tax_",
values_from = all_of(abunMeasure),
values_fill = 0)
}
if(dataType == "occur") {
invert_comms1 = invert_comms1 %>%
dplyr::mutate(dplyr::across(tidyselect::contains("tax_"),
~replace(., . > 0, 1)))
}
colnames(invert_comms1) = sub("tax_", "", colnames(invert_comms1))
invert_comms1 = invert_comms1 %>%
dplyr::select(-SiteVisitSampleNumber,
-Identifier,
-SIDNO,
-ReleaseCategory) %>%
dplyr::relocate(tidyselect::any_of(StreamData:::.ReorderUSGSBioDataColNames))
return(data.frame(invert_comms1))
}
set.seed(4132021)
inverts = getInvertData(
dataType = "occur",
taxonLevel = "Genus",
taxonFix = "remove",
program = "National Water Quality Assessment",
lifestage = FALSE,
abunMeasure = "abundance",
rarefy = TRUE
)
inverts$GenRich = rowSums(inverts[,-c(1:29)])
inverts %>%
# group_by(SiteNumber) %>%
# mutate(count = length(unique(CollectionYear))) %>%
# filter(count > 1) %>%
ggplot(aes(x = CollectionYear, y = GenRich))+
# facet_wrap(~SiteNumber)+
geom_point()+
stat_smooth(method = "lm", se = F)
invert_comms1$GenRich = rowSums(invert_comms1[,-c(1:29)])
invert_comms1 %>%
group_by(SiteNumber) %>%
mutate(count = length(unique(CollectionYear))) %>%
filter(count > 2) %>%
ggplot(aes(x = CollectionYear, y = GenRich))+
facet_wrap(~SiteNumber)+
geom_point()+
stat_smooth(method = "lm", se = F)
invert_comms1 %>%
group_by(SiteNumber) %>%
mutate(count = length(unique(CollectionYear))) %>%
filter(count > 2) %>%
ggplot(aes(x = CollectionYear, y = GenRich))+
# facet_wrap(~SiteNumber)+
geom_point()+
stat_smooth(method = "lm", se = F)
library(StreamData)
set.seed(4132021)
inverts = getInvertData(
dataType = "occur",
taxonLevel = "Genus",
taxonFix = "remove",
program = "National Water Quality Assessment",
lifestage = FALSE,
abunMeasure = "abundance",
rarefy = TRUE
)
inverts$GenRich = rowSums(inverts[,-c(1:29)])
inverts %>%
group_by(SiteNumber) %>%
mutate(count = length(unique(CollectionYear))) %>%
filter(count > 2) %>%
ggplot(aes(x = CollectionYear, y = GenRich))+
# facet_wrap(~SiteNumber)+
# ggbeeswarm::geom_quasirandom()+
geom_point()+
stat_smooth(method = "gam", se = T)+
stat_smooth(method = "lm", se = T)
library(tidyverse)
inverts$GenRich = rowSums(inverts[,-c(1:29)])
inverts %>%
group_by(SiteNumber) %>%
mutate(count = length(unique(CollectionYear))) %>%
filter(count > 2) %>%
ggplot(aes(x = CollectionYear, y = GenRich))+
# facet_wrap(~SiteNumber)+
# ggbeeswarm::geom_quasirandom()+
geom_point()+
stat_smooth(method = "gam", se = T)+
stat_smooth(method = "lm", se = T)
