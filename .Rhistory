### we have to combine the 'Abundance' measures
### (per communication with Scott Grotheer 6-17-19: 'BenchNotes' of duplicated
### entries indicate changed identification/sample type of specimens;
### can combine either 'Abundance' or 'RawCount')
### In order to know which samples are being grouped, we first need to identify
### which 'LabRecordID' are included in the summed 'Abundance' values
### This enables us to track which samples would be included in this measure
### We can also add the unique 'Ratio' included in the duplicates
### (which should be the same for all duplicates)
### Now we can the 'LabRecord_Labels' and 'Ratio_Labels' to the duplicated data
SumGridLLRData <- Gridded_LLRRemoved_Duplicates %>%
dplyr::group_by(SampleGrouping) %>%
dplyr::mutate(LabRecordIDs = paste(LabRecordID, collapse = "_"),
Ratios = paste(Ratio, collapse = "_")) %>%
dplyr::ungroup() %>%
dplyr::mutate(DatasetPortion = "Gridded_LLRRemoved_Duplicates")
## Moving the numeric values of each row to the end of the dataset to better
## visualize the changes we're making
## Removed columns from the dataset that we have created values for
## (e.g., LabRecord_Labels, Ratio_Labels)
## or served their purpose (e.g., Proprietary, SamplerRatio_SamplerType)
## Groups the unique 'SampleGrouping' and sums the 'Abundance' data for each
## Adds the 'SummedAbundance' value to each row based on the 'SampleGrouping' ID
## Removes the first row of each unique 'SampleGrouping'; Takes a single row,
## which we will then place the 'SummedAbundance' value in
## To not overwrite the previous step so we can always modify later
## Replacing the 'Abundance' value with the 'SummedAbundance' value
SumGridLLRData2 = suppressWarnings({SumGridLLRData %>%
dplyr::select(-"LabRecordID", -"NWQLSubsamplingCode", -"Ratio",
-"X", -"NumbEntries") %>%
dplyr::group_by(SampleGrouping) %>%
dplyr::mutate(SummedAbundance = sum(Abundance),
SummedRawCount = sum(RawCount)) %>%
dplyr::ungroup() %>%
dplyr::group_by(SampleGrouping) %>%
dplyr::slice(1) %>%
dplyr::ungroup() %>%
dplyr::mutate(Abundance = SummedAbundance,
Density_m2 = as.numeric("NA"),
AdjRawCount = as.numeric("NA"),
RawCount = SummedRawCount,
TotAreaSampled_m2 = as.numeric("NA"),
FieldSplitRatio = as.numeric("NA"),
Note = "Abundance measure is summed 'Abundance' across multiple inputs
(see 'LabRecordsIDs'); Likely due to changed identification
(e.g., BenchNotes)",
DatasetPortion = "SummedAbundance_Gridded_LLRRemoved") %>%
dplyr::select(-SummedAbundance, -SummedRawCount)})
## Now that we have the corrected summed values for the
## 'Gridded_LLRRemoved_Duplicates', we need to add these rows to the
## non-duplicated rows within the 'SingleRatio' portions
Corrected_Gridded_LLRRemoved <- suppressMessages({dplyr::bind_rows(
(dplyr::anti_join(Invert_MixedSamplerType_GridOnly_LLRRemoved,
Gridded_LLRRemoved_Duplicates) %>%
dplyr::mutate(DatasetPortion =
"NonDuplicate_Gridded_LLRRemoved")),
SumGridLLRData2)})
## We now have to clean the data for sites that used a Folsom Sampler that
## identified invertebrates with multiple 'LabSubsamplingRatio'
### IF n_distinct(LabSubsamplingRatio) == 1, then the sample was either
###  fully counted or only the subsample was entered (WHICH IS WHAT WE WANT)
### IF n_distinct(LabSubsamplingRatio) >= 2, then the sample was split multiple
###  times (FS), or includes "lab large rare" individuals (e.g., species entry
###  will include 1:1 and other subsampled ratio) on a Gridded tray
### So we first filter all sites for those with >= 2 'LabSubsamplingRatio'
### (duplicate STEP 6 action)
## Now that we have these ***FOLSOM SAMPLER ONLY*** samples,
## we can combine the 'Abundance' data for duplicate species entries
### We first have to create a unique variable that encompasses
### each site-by-collection-date-by-biota-by-life-stage combination
Invert_MixedRatios_FolsomSamplerOnly_AntiJoin <- suppressMessages({Inverts %>%
dplyr::group_by(SIDNO, SiteNumber, CollectionDate) %>%
dplyr::filter(dplyr::n_distinct(LabSubsamplingRatio) >= 2) %>%
dplyr::anti_join(Invert_MixedRatios_GridsAndFS)})
## Now we can reduce the dataset to duplicate entries
## We will include both "from the first duplicate" and
## "from the last duplicate" to bookend each duplicate entry
Invert_MixedRatios_Folsom_AntiJoin_Duplicates <-
Invert_MixedRatios_FolsomSamplerOnly_AntiJoin[
duplicated(Invert_MixedRatios_FolsomSamplerOnly_AntiJoin$SampleGrouping)|
duplicated(Invert_MixedRatios_FolsomSamplerOnly_AntiJoin$SampleGrouping,
fromLast = TRUE), ]
## Now that we have all duplicated 'FS' samples, we have to combine the
## 'Abundance' measures (as per communication with Scott Grotheer 5-3-19:
## "always is a pretty BIG word, but I think that (summing 'Abundance')
## is a safe way to go")
### In order to know which samples are being grouped, we first need to
### identify which 'LabRecordID' are included in the summed 'Abundance'
### This enables us to track samples to be included in this summed measure
Invert_MixedRatios_Folsom_AntiJoin_Duplicates <-
Invert_MixedRatios_Folsom_AntiJoin_Duplicates  %>%
dplyr::group_by(SampleGrouping) %>%
dplyr::mutate(LabRecordIDs = paste(LabRecordID, collapse = "_"),
Ratios = paste(Ratio, collapse = "_")) %>%
dplyr::ungroup()
## Moving the numeric values of each row to the end of the dataset to better
## visualize the changes we're making
## Removed columns from the dataset that we have created values for
## (e.g., LabRecord_Labels, Ratio_Labels) or served their purpose
## (e.g., Proprietary, SamplerRatio_SamplerType)
## Groups the unique 'SampleGrouping' and sums the 'Abundance' data
## for each group of values
## Adds the 'SummedAbundance' value to each row based on the 'SampleGrouping' ID
## Removes the first row of each unique 'SampleGrouping';
## Takes a single row, which we will then place the 'SummedAbundance' value in
SumData <- suppressWarnings({Invert_MixedRatios_Folsom_AntiJoin_Duplicates %>%
dplyr::select(-"LabRecordID", -"NWQLSubsamplingCode", -"Ratio",
-"X", -"NumbEntries") %>%
dplyr::group_by(SampleGrouping) %>%
dplyr::mutate(SummedAbundance = sum(Abundance),
SummedRawCount = sum(RawCount)) %>%
dplyr::ungroup() %>%
dplyr::group_by(SampleGrouping) %>%
dplyr::slice(1) %>%
dplyr::ungroup() %>%
dplyr::mutate(Abundance = SummedAbundance,
Density_m2 = as.numeric("NA"),
AdjRawCount = as.numeric("NA"),
RawCount = SummedRawCount,
TotAreaSampled_m2 = as.numeric("NA"),
FieldSplitRatio = as.numeric("NA"),
Note = "Abundance measure is summed 'Abundance' across multiple
folsom sampler inputs (see 'LabRecordsIDs')",
DatasetPortion = "SummedAbundance_FolsomSampler") %>%
dplyr::select(-SummedAbundance, -SummedRawCount)})
Corrected_MixedRatios_FolsomSamplerOnly <- suppressMessages({dplyr::bind_rows((
dplyr::anti_join(Invert_MixedRatios_FolsomSamplerOnly_AntiJoin,
Invert_MixedRatios_Folsom_AntiJoin_Duplicates,
by = "SampleGrouping") %>%
dplyr::mutate(DatasetPortion = "NonDuplicate_FolsomSampler")),
SumData)})
TotalRows <- do.call(dplyr::bind_rows,list(Corrected_MixedRatios_FolsomSamplerOnly,
Corrected_Gridded_LLRRemoved,
Corrected_SingleRatios))
###The above code, hypothetically, could be removed to a separate, hidden
## function. Would take a little bit of work, but could easily be done.
###At this point, we need to join information on stream, site, and sample (?)
## information
### Need to get sampled area from the Sample dataset
###Then, we need to pivot_wider, filter based on taxon level, remove excess
## columns, and change the data type
###Can use code from the "getAlgaeData" function to work on this portion.
###Need to add a section for Lifestage "T/F"; if true count separately, if false count together
invertsamp = utils::read.csv(system.file("extdata",
"20201217.0749.InvertSamp.csv",
package = "StreamData"),
colClasses = c("SiteNumber" = "character"),
stringsAsFactors = FALSE) %>%
dplyr::rename(SIDNO = grep("SIDNO", names(.))) %>%
dplyr::select(SIDNO,
SiteNumber,
AreaSampTot_m2,
GeomorphicChannelUnit,
ChannelBoundaries,
ChannelFeatures)
invertsampinv = utils::read.csv(system.file("extdata",
"20201217.0749.SampleInv.csv",
package = "StreamData"),
colClasses = c("SiteNumber" = "character"),
stringsAsFactors = FALSE) %>%
dplyr::rename(SIDNO = grep("SIDNO", names(.))) %>%
dplyr::select(SIDNO,
ReplicateType)
invertsite = utils::read.csv(system.file("extdata",
"20201217.0749.SiteInfo.csv",
package = "StreamData"),
colClasses = c("SiteNumber" = "character"),
stringsAsFactors = FALSE) %>%
dplyr::select(SiteNumber,
Latitude_dd,
Longitude_dd,
CoordinateDatum,
HUCCode,
DrainageArea_mi2,
SiteTypeName,
CountyFIPSCode,
StateFIPSCode)
invertsampinfo = dplyr::left_join(dplyr::left_join(invertsamp,
invertsampinv,
by = "SIDNO"),
invertsite,
by = "SiteNumber") %>%
dplyr::select(-SiteNumber) %>%
dplyr::mutate(CountyFIPSCode = sprintf("%03d", CountyFIPSCode),
StateFIPSCode = sprintf("%02d", StateFIPSCode))
TotalRows = dplyr::left_join(TotalRows,
invertsampinfo,
by = "SIDNO")
if(abunMeasure == "abundance"){
abunMeasure = "Abundance"
notAbun <- "Density_m2"
} else {
notAbun <- "Abundance"
abunMeasure <- "Density_m2"}
mycols = StreamData:::.TaxLevCols_Inverts[[which(names(StreamData:::.TaxLevCols_Inverts) == taxonLevel)]]$mycols
taxcols = StreamData:::.TaxLevCols_Inverts[[which(names(StreamData:::.TaxLevCols_Inverts) == taxonLevel)]]$taxcols
##MIKE NOTE BELOW
###NOTE: NEED TO MOVE THIS AFTER THE RANDOM SAMPLING, BECAUSE IT IS CAUSING SAMPLES TO BE DROPPED
##THIS COULD AFFECT SOME THINGS, BUT MIGHT BE REALLY EASY
if(isTRUE(rarefy)) {
TotalRows = TotalRows %>%
dplyr::group_by(SIDNO) %>%
dplyr::mutate(indcounted = sum(RawCount)) %>%
dplyr::filter(indcounted > 299) %>%
dplyr::select(-indcounted) %>%
dplyr::ungroup() %>%
dplyr::group_by(SIDNO) %>%
dplyr::slice(rep(1:n(), times=RawCount)) %>%
dplyr::sample_n(size = 300) %>%
dplyr::group_by(SIDNO, PublishedTaxonName) %>%
dplyr::slice(1) %>%
dplyr::ungroup()
} else {}
##SLR - ADD OPTIONS TO 1) GROUP PROBLEMATIC IDENTIFICATIONS OR 2) THROW OUT PROBLEMATIC OBSERVATION WITH MISSING SPP DATA
#create variable taxonFix = none, lump, remove
#none = no change, lump = lump genera through time, remove = remove observation only if spp. level ID does not exist
if(taxonFix == "none"){
}else if(taxonFix == "lump"){
#create bench genus in TotalRows
TotalRows <- TotalRows %>%
dplyr::mutate(BenchGenus = as.character(gsub( " .*$", "", BenchTaxonName)))
#If bench genera that are one of bench genera in clust_labels, rename the Genus with the lump label from clust_labels
#else, keep the original Genus label
TotalRows$Genus <- ifelse(TotalRows$BenchGenus %in% StreamData:::.clust_labels$genus,
StreamData:::.clust_labels$lump[match(TotalRows$BenchGenus,StreamData:::.clust_labels$genus)],
TotalRows$Genus)
TotalRows <- TotalRows %>%
dplyr::select(-BenchGenus)
}else if(taxonFix == "remove"){
#filter out rows that have bench genus from problem list & no species ID
TotalRows <- TotalRows %>%
dplyr::filter(!(Genus %in% StreamData:::.clust_labels$genus & PublishedTaxonNameLevel == "Genus"))
}
if(isTRUE(lifestage)) {
#Lifestage-taxon combinations
invert_comms1 = TotalRows %>%
dplyr::filter(PublishedTaxonNameLevel %in% taxcols) %>%
dplyr::filter_at(vars(all_of(taxonLevel)), any_vars(. != "")) %>%
tidyr::unite(UNIQUEID, c(SIDNO, all_of(taxonLevel), Lifestage), sep = "_", remove = FALSE) %>%
dplyr::group_by(UNIQUEID) %>%
dplyr::mutate(Abundance = sum(Abundance)) %>%
dplyr::slice(1) %>%
dplyr::ungroup() %>%
dplyr::mutate(Density_m2 = ifelse(is.na(AreaSampTot_m2),
NA,
Abundance / AreaSampTot_m2)) %>%
dplyr::select(-any_of(c("LabOrderID", "LabRecordID", "FieldComponent",
"LabComponent", "LabProcName",
"TaxonomicResultReviewStatus",
"PublishedSortOrder", "BioDataTaxonName", "BioDataShortName",
"BenchTaxonName", "BenchTaxonNameReferenceCode",
"AdjRawCount", "RawCount",
"FieldSplitRatio", "LabSubsamplingRatio", "UniqueTaxonFlag",
"TargetLevelNotReachedReason", "Artifact", "BenchNotes",
"TaxonRecordSource", "IdentificationDate",
"VerificationEntity", "VerificationDate", "CurationEntity",
"CurationDate", 'ITIS_TSN', "ITIS_MatchCode", "PublishedTaxonName",
"PublishedTaxonNameAuthority", "ScientificName",
"TaxonVersionNumber", "NWQLSubsamplingCode",
"Ratio", 'X', "NumbEntries", "SampleGrouping", "LabRecordIDs",
"Ratios", "Note", "UNIQUEID", "PublishedTaxonNameLevel",
"SamplerType", "DatasetPortion", "TotAreaSampled_m2"))) %>%
dplyr::select(-any_of(mycols),
-any_of(notAbun)) %>%
tidyr::unite(Taxon_Life, c(all_of(taxonLevel), Lifestage), sep = "_") %>%
tidyr::pivot_wider(names_from = all_of(Taxon_Life),
names_prefix = "tax_",
values_from = all_of(abunMeasure),
values_fill = 0)
} else {
#All species are one
invert_comms1 = TotalRows %>%
dplyr::filter(PublishedTaxonNameLevel %in% taxcols) %>%
dplyr::filter_at(vars(all_of(taxonLevel)), any_vars(. != "")) %>%
tidyr::unite(UNIQUEID, c(SIDNO, all_of(taxonLevel)), sep = "_", remove = FALSE) %>%
dplyr::group_by(UNIQUEID) %>%
dplyr::mutate(Abundance = sum(Abundance)) %>%
dplyr::slice(1) %>%
dplyr::ungroup() %>%
dplyr::mutate(Density_m2 = ifelse(is.na(AreaSampTot_m2),
NA,
Abundance / AreaSampTot_m2)) %>%
dplyr::select(-tidyselect::any_of(c("LabOrderID", "LabRecordID", "FieldComponent",
"LabComponent", "LabProcName",
"TaxonomicResultReviewStatus",
"PublishedSortOrder", "BioDataTaxonName", "BioDataShortName",
"BenchTaxonName", "BenchTaxonNameReferenceCode",
"AdjRawCount", "RawCount",
"FieldSplitRatio", "LabSubsamplingRatio", "UniqueTaxonFlag",
"TargetLevelNotReachedReason", "Artifact", "BenchNotes",
"TaxonRecordSource", "IdentificationDate",
"VerificationEntity", "VerificationDate", "CurationEntity",
"CurationDate", 'ITIS_TSN', "ITIS_MatchCode", "PublishedTaxonName",
"PublishedTaxonNameAuthority", "ScientificName",
"TaxonVersionNumber", "NWQLSubsamplingCode",
"Ratio", 'X', "NumbEntries", "SampleGrouping", "LabRecordIDs",
"Ratios", "Note", "Lifestage", "UNIQUEID", "PublishedTaxonNameLevel",
"SamplerType", "DatasetPortion", "TotAreaSampled_m2"))) %>%
dplyr::select(-tidyselect::any_of(mycols)) %>%
dplyr::select(-tidyselect::any_of(notAbun)) %>%
tidyr::pivot_wider(names_from = all_of(taxonLevel),
names_prefix = "tax_",
values_from = all_of(abunMeasure),
values_fill = 0)
}
if(dataType == "occur") {
invert_comms1 = invert_comms1 %>%
dplyr::mutate(dplyr::across(tidyselect::contains("tax_"),
~replace(., . > 0, 1)))
}
colnames(invert_comms1) = sub("tax_", "", colnames(invert_comms1))
invert_comms1 = invert_comms1 %>%
dplyr::select(-SiteVisitSampleNumber,
-Identifier,
-SIDNO,
-ReleaseCategory) %>%
dplyr::relocate(tidyselect::any_of(StreamData:::.ReorderUSGSBioDataColNames))
return(data.frame(invert_comms1))
}
set.seed(4132021)
inverts = getInvertData(
dataType = "occur",
taxonLevel = "Genus",
taxonFix = "remove",
program = "National Water Quality Assessment",
lifestage = FALSE,
abunMeasure = "abundance",
rarefy = TRUE
)
colnames(inverts)
inverts$GenRich = rowSums(inverts[,-c(1:29)])
inverts %>%
group_by(SiteNumber) %>%
mutate(count = length(unique(CollectionYear))) %>%
filter(count > 1) %>%
ggplot(aes(x = CollectionYear, y = GenRich))+
# facet_wrap(~SiteNumber)+
geom_point()+
stat_smooth(method = "lm", se = F)
library(tidyverse)
set.seed(4132021)
inverts = getInvertData(
dataType = "occur",
taxonLevel = "Genus",
taxonFix = "remove",
program = "National Water Quality Assessment",
lifestage = FALSE,
abunMeasure = "abundance",
rarefy = TRUE
)
colnames(inverts)
inverts$GenRich = rowSums(inverts[,-c(1:29)])
inverts %>%
group_by(SiteNumber) %>%
mutate(count = length(unique(CollectionYear))) %>%
filter(count > 1) %>%
ggplot(aes(x = CollectionYear, y = GenRich))+
# facet_wrap(~SiteNumber)+
geom_point()+
stat_smooth(method = "lm", se = F)
inverts %>%
group_by(SiteNumber) %>%
mutate(count = length(unique(CollectionYear))) %>%
filter(count > 2) %>%
ggplot(aes(x = CollectionYear, y = GenRich))+
facet_wrap(~SiteNumber)+
geom_point()+
stat_smooth(method = "lm", se = F)
inverts %>%
group_by(SiteNumber) %>%
mutate(count = length(unique(CollectionYear))) %>%
filter(count > 2) %>%
ggplot(aes(x = CollectionYear, y = GenRich))+
# facet_wrap(~SiteNumber)+
geom_point()+
stat_smooth(method = "gam", se = F)
inverts %>%
group_by(SiteNumber) %>%
mutate(count = length(unique(CollectionYear))) %>%
filter(count > 2) %>%
ggplot(aes(x = CollectionYear, y = GenRich))+
# facet_wrap(~SiteNumber)+
geom_point()+
stat_smooth(method = "gam", se = T)
inverts %>%
group_by(SiteNumber) %>%
mutate(count = length(unique(CollectionYear))) %>%
filter(count > 2) %>%
ggplot(aes(x = CollectionYear, y = GenRich))+
# facet_wrap(~SiteNumber)+
geom_point()+
stat_smooth(method = "gam", se = T)+
stat_smooth(method = "lm", se = T)+
length(unique(inverts$SiteNumber))
inverts %>%
group_by(SiteNumber) %>%
mutate(count = length(unique(CollectionYear))) %>%
filter(count > 2) %>%
ggplot(aes(x = CollectionYear, y = GenRich))+
# facet_wrap(~SiteNumber)+
geom_point()+
stat_smooth(method = "gam", se = T)+
stat_smooth(method = "lm", se = T)
inverts %>%
group_by(SiteNumber) %>%
mutate(count = length(unique(CollectionYear))) %>%
filter(count > 2) %>%
ggplot(aes(x = CollectionYear, y = GenRich))+
# facet_wrap(~SiteNumber)+
geom_point()+
stat_smooth(method = "gam", se = T)+
stat_smooth(method = "lmer", se = T)
inverts %>%
group_by(SiteNumber) %>%
mutate(count = length(unique(CollectionYear))) %>%
filter(count > 2) %>%
ggplot(aes(x = CollectionYear, y = GenRich))+
# facet_wrap(~SiteNumber)+
ggbeeswarm::geom_quasirandom()+
stat_smooth(method = "gam", se = T)+
stat_smooth(method = "lm", se = T)
devtools::document()
rm(list = c("getInvertData"))
devtools::document()
devtools::build()
inverts %>%
group_by(SiteNumber) %>%
mutate(count = length(unique(CollectionYear))) %>%
filter(count > 2) %>%
ggplot(aes(x = CollectionYear, y = GenRich))+
# facet_wrap(~SiteNumber)+
# ggbeeswarm::geom_quasirandom()+
geom_point()+
stat_smooth(method = "gam", se = T)+
stat_smooth(method = "lm", se = T)
Inverts <- utils::read.csv(unzip(system.file("extdata",
"InvertResults.zip",
package = "StreamData")),
colClasses = c("SiteNumber" = "character"),
stringsAsFactors = FALSE)
if(colnames(Inverts)[1] != "SIDNO"){
colnames(Inverts)[1] = "SIDNO"
}
system.file("extdata",
"InvertResults.zip",
package = "StreamData")
file.exists(system.file("extdata",
"20201217.0749.InvertResults.csv",
package = "StreamData"))
if(file.exists(system.file("extdata",
"20201217.0749.InvertResults.csv",
package = "StreamData"))){
unlink(system.file("extdata",
"20201217.0749.InvertResults.csv",
package = "StreamData"))
}
algae = utils::read.csv(unzip(system.file("extdata",
"AlgaeResults.zip",
package = "StreamData")),
colClasses = c("SiteNumber" = "character"))
file.exists(system.file("extdata",
"20201217.0757.AlgResults.csv",
package = "StreamData"))
if(file.exists(system.file("extdata",
"20201217.0757.AlgResults.csv",
package = "StreamData"))){
unlink(system.file("extdata",
"20201217.0757.AlgResults.csv",
package = "StreamData"))
}
fish <- utils::read.csv(unzip(system.file("extdata",
"FishResults.zip",
package = "StreamData")),
colClasses = c("SiteNumber" = "character"))
file.exists(system.file("extdata",
"20201217.0745.FishResults.csv",
package = "StreamData"))
##Remove the unzipped file from the system
if(file.exists(system.file("extdata",
"20201217.0745.FishResults.csv",
package = "StreamData"))){
unlink(system.file("extdata",
"20201217.0745.FishResults.csv",
package = "StreamData"))
}
pest.dat <- utils::read.table(unzip(system.file("extdata",
"PestEst.zip",
package = "StreamData")),
sep = "\t", header= T,
colClasses = c("STATE_FIPS_CODE" = "character",
"COUNTY_FIPS_CODE" = "character"))  %>%
mutate(compound = stringr::str_to_lower(COMPOUND))
file.exists(system.file("extdata",
"pestCountyEstYrs.txt",
package = "StreamData"))
##Remove the unzipped file from the system
if(file.exists(system.file("extdata",
"pestCountyEstYrs.txt",
package = "StreamData"))){
unlink(system.file("extdata",
"pestCountyEstYrs.txt",
package = "StreamData"))
}
devtools::document()
devtools::build()
install.packages("C:/Users/mikem/Documents/R Package Builds/StreamData_0.0.0.9000.tar.gz", repos = NULL, source = "local")
detach("package:StreamData", unload = TRUE)
install.packages("C:/Users/mikem/Documents/R Package Builds/StreamData_0.0.0.9000.tar.gz", repos = NULL, source = "local")
devtools::document()
devtools::build()
devtools::document()
?getInvertData
